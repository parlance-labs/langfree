# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_runs.ipynb.

# %% auto 0
__all__ = ['client', 'check_api_key', 'take', 'get_runs_by_commit', 'get_last_child', 'get_recent_runs', 'get_recent_commit_tags',
           'get_input', 'get_output', 'get_params', 'get_functions', 'get_feedback']

# %% ../nbs/01_runs.ipynb 2
from collections import defaultdict
import os
from datetime import date, timedelta, datetime
from itertools import islice
from typing import List, Iterable
from pprint import pformat
from contextlib import contextmanager

import pandas as pd
from langchain.load import load
import langsmith
from langsmith import Client
from fastcore.foundation import L, first

# %% ../nbs/01_runs.ipynb 3
@contextmanager
def _temp_env_var(vars_dict):
    "Temporarily set environment variables (for testing)"
    original_values = {name: os.environ.get(name) for name in vars_dict.keys()}
    
    # Set temporary values
    for name, value in vars_dict.items():
        os.environ[name] = value
        
    try:
        yield
    finally:
        # Revert changes after block execution
        for name, original_value in original_values.items():
            if original_value is None:
                del os.environ[name]
            else:
                os.environ[name] = original_value

# %% ../nbs/01_runs.ipynb 4
def check_api_key(nm="LANGCHAIN_HUB_API_KEY"):
    val = os.getenv(nm)
    if not val: raise Exception(f"You must set the environment variable {nm}")
    return val

# %% ../nbs/01_runs.ipynb 5
check_api_key("LANGCHAIN_API_KEY")
check_api_key("LANGCHAIN_ENDPOINT")
check_api_key("LANGSMITH_PROJECT_ID")
client = Client()

# %% ../nbs/01_runs.ipynb 7
def take(l:Iterable, n:int):
    "Take first n entries from a generator"
    return L(islice(l, n))

# %% ../nbs/01_runs.ipynb 8
def get_runs_by_commit(commit_id:str=None, # The commit ID to filter by 
             proj_id:str=None, # Langsmith Project ID
             only_success=True, # Only include runs that are successfull
             run_type='chain', # The run type
             start_dt:str=None, # The start date to filter by
             end_dt:str=None    # the end date to filter by
            ):
    "Get all runs tagged with a particular commit id (the short version of the SHA) in LangSmith."
    
    success_query='eq(status, "success")' if only_success else ''
    commit_query = f'has(tags, "commit:{commit_id}")' if commit_id else ''
    proj_id = check_api_key("LANGSMITH_PROJECT_ID") if not proj_id else proj_id
    time_query=''
    
    if start_dt:
        time_query=f'gte(start_time, "{start_dt}")'
        if end_dt:
            time_query = f'{time_query}, lte(start_time, "{end_dt}")'
    
    queries = ', '.join(L([success_query, commit_query, time_query]).filter())
    query_string = None if not queries else f'and({queries})'
    if query_string: print(f'Fetching runs with this filter: {query_string}')
        
    runs = client.list_runs(
        filter=query_string,
        project_id=proj_id,
        execution_order=1, # this gets the root runs
        error=False,
        run_type=run_type,
    )
    return runs

# %% ../nbs/01_runs.ipynb 12
def get_last_child(runs: List[langsmith.schemas.Run]):
    "Get the child runs for a list of runs."
    return [client.read_run(r.child_run_ids[-1]) for r in runs if r.child_run_ids]

# %% ../nbs/01_runs.ipynb 15
def get_recent_runs(start_dt=None, end_dt=None, last_n_days=2):
    "Get recent runs from Langsmith.  If `start_dt` is None gets the `last_n_days`."
    if start_dt is None:
        _runs = client.list_runs(project_id=check_api_key("LANGSMITH_PROJECT_ID"), limit=1)
        latest_run_dt = first(_runs).start_time
        start_dt_obj = latest_run_dt - timedelta(days=last_n_days)
    else:
        start_dt_obj = datetime.strptime(start_dt, '%m/%d/%Y')
        
    if end_dt is None:
        if start_dt is None:
            end_dt_obj = start_dt_obj + timedelta(days=last_n_days+1) # their logic is off lte is really lt
        else:
            end_dt_obj = datetime.strptime(start_dt, '%m/%d/%Y') + timedelta(days=last_n_days+1) # their logic is off lte is really lt   
    else:
        if start_dt is None:
            raise ValueError("end_dt should only be provided if start_dt is provided.")
        end_dt_obj = datetime.strptime(end_dt, '%m/%d/%Y')
    
    
    runs = get_runs_by_commit(start_dt=start_dt_obj.strftime('%m/%d/%Y'),
                    end_dt=end_dt_obj.strftime('%m/%d/%Y'))
    return runs

# %% ../nbs/01_runs.ipynb 19
def get_recent_commit_tags(start_dt=None, end_dt=None, last_n_days=2, return_df=False):
    "Print a table of recent commit SHAs from Langsmith along with their counts that you can filter on"
    runs = L(get_recent_runs(start_dt=start_dt, end_dt=end_dt, last_n_days=last_n_days))
    data = runs.map(lambda x: {'start_dt': x.start_time.strftime('%m/%d/%Y'),
                        'commit': first([t.split('commit:')[-1] for t in x.tags if t.startswith('commit:')])
                       }
            )
    if data:
        df = pd.DataFrame(data)
        agg = df.groupby(['start_dt']).value_counts().reset_index()
        agg = agg.rename(columns={0: 'count'}).sort_values(by=['start_dt', 'count'], ascending=False)
        if not return_df:
            print(agg.to_markdown(index=False))
        else:
            return agg
        
    else:
        print(f'No commits found for {start_dt} - {end_dt}')
        return None

# %% ../nbs/01_runs.ipynb 27
def _ischatopenai(run): 
    if run.name != 'ChatOpenAI':
        raise TypeError(f'Run: {run.id} is of type `{run.name}`, but can only parse `ChatOpenAI` runs.')

def get_input(run:langsmith.schemas.Run):
    "Get flattened, human-readable input from a ChatOpenAI run."
    _ischatopenai(run)
    inp = ''
    for m in  L(run.inputs['messages']):
        actor = m['id'][-1]
        content = m['kwargs']['content']
        if m['kwargs']['additional_kwargs']:
            content += pformat(m['kwargs']['additional_kwargs'])
        inp += f'## Source: {actor}\n\n {content}\n\n'
    return inp

# %% ../nbs/01_runs.ipynb 32
def get_output(run:langsmith.schemas.Run):
    "Get flattened output from a child run"
    return run.outputs['generations'][0]['text']

# %% ../nbs/01_runs.ipynb 35
def get_params(run:langsmith.schemas.Run) -> dict:
    "Get parameters from a run logged in LangSmith"
    if 'invocation_params' in run.extra:
        p = run.extra['invocation_params']
        return dict(param_model_name=p.get('model'),
                    param_n=p.get('n'),
                    param_top_p=p.get('top_p'),
                    param_temp=p.get('temperature'),
                    param_presence_penalty=p.get('presence_penalty'),
                    param_freq_penalty=p.get('frequency_penalty')
                   )
    else: return {}    

# %% ../nbs/01_runs.ipynb 37
def get_functions(run:langsmith.schemas.Run) -> List[dict]:
    "Get function definitions from a LangSmith run."
    if 'invocation_params' in run.extra:
        p = run.extra['invocation_params']
        return p.get('functions', [])
    else: return []

# %% ../nbs/01_runs.ipynb 40
def get_feedback(run:langsmith.schemas.Run) -> list:
    "Get feedback from a run if exists."
    raw = L(client.list_feedback(run_ids=[run.id]))
    return list(raw.map(lambda x: dict(key=x.key, 
                                       score=x.score, 
                                       value=x.value, 
                                       comment=x.comment, 
                                       correction=x.correction)
                       )
               )
