# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_chatrecord.ipynb.

# %% auto 0
__all__ = ['NoChatOpenAI', 'get_child_chat_run', 'ChatRecord', 'ChatRecordSet']

# %% ../nbs/03_chatrecord.ipynb 2
from typing import List, Iterable, Union
from collections import Counter
from pathlib import Path
import pickle

import pandas as pd
from pydantic import BaseModel
import langsmith
from fastcore.foundation import first, L
from fastcore.test import test_eq
from .runs import (get_runs_by_commit, 
                           get_params, get_functions,
                          get_feedback)
from .transform import RunData
from langsmith import Client

# %% ../nbs/03_chatrecord.ipynb 4
class NoChatOpenAI(Exception):
    def __init__(self, message, extra_data=None):
        super().__init__(message)

# %% ../nbs/03_chatrecord.ipynb 5
def get_child_chat_run(run):
    "Get the last child `ChatOpenAI` run."
    client = Client()
    if run.parent_run_id is not None:
    # if run.execution_order != 1: # this is a child run, get the parent
        run = client.read_run(run.parent_run_id)
            
    _cruns = client.read_run(run_id=run.id, load_child_runs=True).child_runs
    crun = None
    
    if _cruns:
        chatoai_runs = [c for c in _cruns if c.name == 'ChatOpenAI']
        if chatoai_runs: 
            return run, chatoai_runs[-1]
        else: raise NoChatOpenAI(f'Not able to find ChatOpenAI child run from root run {run.id}')
    else: 
        return run, crun

# %% ../nbs/03_chatrecord.ipynb 7
class ChatRecord(BaseModel):
    "A parsed run from LangSmith, focused on the `ChatOpenAI` run type."
    child_run_id:str
    child_run:RunData
    child_url:Union[str,None] = None
    parent_run_id:Union[str,None] = None
    parent_url: Union[str,None] = None
    total_tokens:Union[int, None]
    prompt_tokens:Union[int, None]
    completion_tokens:Union[int, None]
    feedback: Union[List,None] = None
    feedback_keys: Union[List,None] = None
    tags: Union[List,None] = []
    start_dt: Union[str, None] = None
    function_defs: Union[List,None] = None
    param_model_name: Union[str,None]= None
    param_n: Union[int, None] = None
    param_top_p: Union[int, None] = None
    param_temp: Union[int, None] = None
    param_presence_penalty: Union[int, None] = None
    param_freq_penalty: Union[int, None] = None

    @property
    def flat_input(self): return self.child_run.flat_input
    
    @property
    def flat_output(self): return self.child_run.flat_output

    @classmethod
    def from_run_id(cls, 
                    run_id:str # the run id to fetch and parse.
                   ):
        "Collect information About A Run into a `ChatRecord`."
        client = Client()
        return cls.from_run(client.read_run(run_id=run_id))
    
    @classmethod
    def from_run(cls, 
                 run:langsmith.schemas.Run # the run object to parse.
                ):
        "Collect information About A Run into a `ChatRecord`."
        run, crun = get_child_chat_run(run)
    
        if crun:
            params = get_params(crun)
            _feedback = get_feedback(run) # you must get feedback from the root
            
            return cls(child_run_id=str(crun.id),
                       child_run=RunData.from_run_id(str(crun.id)),
                       child_url=crun.url,
                       parent_run_id=str(run.id) if run else None,
                       parent_url=run.url if run else None,
                       total_tokens=crun.total_tokens,
                       prompt_tokens=crun.prompt_tokens,
                       completion_tokens=crun.completion_tokens,
                       feedback=_feedback, 
                       feedback_keys=list(L(_feedback).attrgot('key').filter()),
                       tags=run.tags,
                       start_dt=run.start_time.strftime('%m/%d/%Y'),
                       function_defs=get_functions(crun),
                       **params)

# %% ../nbs/03_chatrecord.ipynb 16
class ChatRecordSet(BaseModel):
    "A List of `ChatRecord`."
    records: List[ChatRecord]
    
    @classmethod
    def from_commit(cls, commit_id:str, limit:int=None):
        "Create a `ChatRecordSet` from a commit id"
        _runs = get_runs_by_commit(commit_id=commit_id, limit=limit)
        return cls.from_runs(_runs)
    
    @classmethod
    def from_runs(cls, runs:List[langsmith.schemas.Run]):
        "Load ChatRecordSet from runs."
        _records = []
        for r in runs:
            try: _records.append(ChatRecord.from_run(r))
            except NoChatOpenAI as e: print(e) 
        return cls(records=_records)

    @classmethod
    def from_run_ids(cls, runs:List[str]):
        "Load ChatRecordSet from run ids."
        _records = []
        for r in runs:
            try: _records.append(ChatRecord.from_run_id(r))
            except NoChatOpenAI as e: print(e)
        return cls(records=_records)
    
    def __len__(self): return len(self.records)

    def __getitem__(self, index: int) -> ChatRecord:
        return self.records[index]

    def __repr__(self):
        return f'`List[ChatRecord]` of size {len(self.records)}.'
    
    def save(self, path:str):
        "Save data to disk."
        dest_path = Path(path)
        if not dest_path.parent.exists(): dest_path.parent.mkdir(exist_ok=True)
        with open(dest_path, 'wb') as f:
            pickle.dump(self, f)
            return dest_path
        
    def __iter__(self): 
        for r in self.records: 
            yield r
    
    @classmethod
    def load(cls, path:str):
        "Load data from disk."
        src_path = Path(path)
        with open(src_path, 'rb') as f:
            obj = pickle.load(f)
            if isinstance(obj, cls):
                return obj
            else:
                raise TypeError(f"The loaded object is not of type {cls.__name__}")
                
    def to_pandas(self):
        "Convert the `ChatRecordSet` to a pandas.DataFrame."
        records = L(self.records).map(dict)                      
        return pd.DataFrame(records)

    def to_dicts(self):
        "Convert the ChatRecordSet to a list of dicts, which you can convert to jsonl."
        return list(L(self.records).map(lambda x: x.child_run.to_msg_dict()))
